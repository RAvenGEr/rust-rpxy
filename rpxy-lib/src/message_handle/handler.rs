use super::{
  http_log::HttpMessageLog,
  http_result::{HttpError, HttpResult},
  synthetic_response::{secure_redirection_response, synthetic_error_response},
  utils_request::ParseHost,
};
use crate::{
  backend::BackendAppManager,
  crypto::CryptoSource,
  error::*,
  globals::Globals,
  hyper_ext::body::{BoxBody, IncomingLike, IncomingOr},
  log::*,
  name_exp::ServerName,
};
use derive_builder::Builder;
use http::{Request, Response, StatusCode};
use std::{net::SocketAddr, sync::Arc};

#[derive(Clone, Builder)]
/// HTTP message handler for requests from clients and responses from backend applications,
/// responsible to manipulate and forward messages to upstream backends and downstream clients.
// pub struct HttpMessageHandler<T, U>
pub struct HttpMessageHandler<U>
where
  // T: Connect + Clone + Sync + Send + 'static,
  U: CryptoSource + Clone,
{
  // forwarder: Arc<Forwarder<T>>,
  globals: Arc<Globals>,
  app_manager: Arc<BackendAppManager<U>>,
}

impl<U> HttpMessageHandler<U>
where
  // T: Connect + Clone + Sync + Send + 'static,
  U: CryptoSource + Clone,
{
  /// Handle incoming request message from a client.
  /// Responsible to passthrough responses from backend applications or generate synthetic error responses.
  pub async fn handle_request(
    &self,
    mut req: Request<IncomingOr<IncomingLike>>,
    client_addr: SocketAddr, // For access control
    listen_addr: SocketAddr,
    tls_enabled: bool,
    tls_server_name: Option<ServerName>,
  ) -> RpxyResult<Response<IncomingOr<BoxBody>>> {
    let mut log_data = HttpMessageLog::from(&req);

    let http_result = self
      .handle_request_inner(
        &mut log_data,
        req,
        client_addr,
        listen_addr,
        tls_enabled,
        tls_server_name,
      )
      .await;

    // passthrough or synthetic response
    match http_result {
      Ok(v) => {
        log_data.status_code(&v.status()).output();
        Ok(v)
      }
      Err(e) => {
        debug!("{e}");
        let code = StatusCode::from(e);
        log_data.status_code(&code).output();
        synthetic_error_response(code)
      }
    }
  }

  /// Handle inner with no synthetic error response.
  /// Synthetic response is generated by caller.
  async fn handle_request_inner(
    &self,
    mut log_data: &mut HttpMessageLog,
    mut req: Request<IncomingOr<IncomingLike>>,
    client_addr: SocketAddr, // For access control
    listen_addr: SocketAddr,
    tls_enabled: bool,
    tls_server_name: Option<ServerName>,
  ) -> HttpResult<Response<IncomingOr<BoxBody>>> {
    // preparing log data
    let mut log_data = HttpMessageLog::from(&req);
    log_data.client_addr(&client_addr);

    // Here we start to handle with server_name
    let server_name = req.parse_host().map(ServerName::from)?;

    // check consistency of between TLS SNI and HOST/Request URI Line.
    #[allow(clippy::collapsible_if)]
    if tls_enabled && self.globals.proxy_config.sni_consistency {
      if server_name != tls_server_name.unwrap_or_default() {
        return Err(HttpError::SniHostInconsistency);
      }
    }
    // Find backend application for given server_name, and drop if incoming request is invalid as request.
    let backend_app = match self.app_manager.apps.get(&server_name) {
      Some(backend_app) => backend_app,
      None => {
        let Some(default_server_name) = &self.app_manager.default_server_name else {
          return Err(HttpError::NoMatchingBackendApp);
        };
        debug!("Serving by default app");
        self.app_manager.apps.get(default_server_name).unwrap()
      }
    };

    // Redirect to https if !tls_enabled and redirect_to_https is true
    if !tls_enabled && backend_app.https_redirection.unwrap_or(false) {
      debug!(
        "Redirect to secure connection: {}",
        <&ServerName as TryInto<String>>::try_into(&backend_app.server_name).unwrap_or_default()
      );
      return secure_redirection_response(&backend_app.server_name, self.globals.proxy_config.https_port, &req);
    }

    //////////////
    // // TODO: remove later
    let body = crate::hyper_ext::body::full(hyper::body::Bytes::from("not yet implemented"));
    let res = super::synthetic_response::synthetic_response(Response::builder().body(body).unwrap());
    Ok(res)
    //////////////
    // todo!()
  }
}
